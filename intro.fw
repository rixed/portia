Portia: a text processor for literate programs
==============================================

We want a simple tool to build literate programs, with those
requirements:

R1. must be able to build itself
R2. must be bootstrapable with funnelweb
R3. add correct file and line number infos into generated source code
R4. do not output doc; rather, make code extraction flexible enough for the doc
    to be written in any documentation language in the first place
R5. code blocks may be inline
R6. must not require to have all the text, nor all the code, present in memory
R7. to make references to locally defined code blocks smaller, an optional
    namespace may be appended to force a reference lookup to consider only the
    code blocks defined in the designated file (which name is given relative to
    root file)

It follows from R1 and R2 that we should either follow funnelweb syntax,
which is awful, or build a tool that's flexible enough to act like funnelweb
(or at least, that can understand a workable subset of funnelweb syntax).

Ideally, all escaping sequences of the macro system can be redefined.
When bootstrapping (with the actual funnelweb) we do not mind the quality of
the generated documentation since we can produce a better documentation (and
source code, thanks to requirement R3 & R4) from recompiling with the
bootstrapped processor.

For generating source code, we need a very few commands:

- define and name a block of code (see R5)
- reference a block of code by name (from another block of code or from the
  literate text)
- define and output to a file a block of code

R8. can split content into several files

Since we do not care about the order in which the code fragments will be
encountered, and we do not care neither in what order we scan the documentation
(since we do not produce a documentation according to R4, then we can merely be
given a list of files to scan. We do not need an include directive as funnelweb
(and other) does.

Still, many documentation language has an include directive and if we were able
to follow it then we could alleviate the user for the need to maintain this
list of files (since we could find everything from the root document).

So we do both: we will scan everything from the command line and additionally,
if we are taught how to spot an include directive, then we will try to follow
it.


We are going to use the OCaml language because it's compendious yet fast.
The filters may be defined in OCaml.

@i definitions.fw
@i main.fw
@i parsing.fw
@i output.fw
@i config.fw
